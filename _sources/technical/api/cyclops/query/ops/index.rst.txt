:py:mod:`cyclops.query.ops`
===========================

.. py:module:: cyclops.query.ops

.. autoapi-nested-parse::

   Low-level query operations.

   This module contains query operation modules such as AddColumn, Join, DropNulls, etc.
   which can be used in high-level query API functions specific to datasets.

   ..
       !! processed by numpydoc !!


Module Contents
---------------

.. py:class:: QAP

   
   Query argument placeholder (QAP) class.

   :param kwarg_name: Name of keyword argument for which this classs
                      acts as a placeholder.
   :type kwarg_name: str
   :param required: Whether the keyword argument is required to run the process.
   :type required: bool
   :param transform_fn: A function accepting and transforming the passed in argument.
   :type transform_fn: callable















   ..
       !! processed by numpydoc !!
   .. py:method:: __repr__()

      
      Return the name of the placeholded keyword argument.

      :returns: The name of the keyword argument.
      :rtype: str















      ..
          !! processed by numpydoc !!

   .. py:method:: __call__(**kwargs)

      
      Recover the value of the placeholder argument.

      :param \*\*kwargs: kwarg which corresponds to self.kwarg_name as a key with a
                         corresponding value.
      :type \*\*kwargs: Any

      :returns: Value of the placeholder argument.
      :rtype: any















      ..
          !! processed by numpydoc !!


.. py:function:: process_operations(table: cyclops.query.util.TableTypes, operations: List[tuple], user_kwargs: dict) -> sqlalchemy.sql.selectable.Subquery

   
   Query MIMIC encounter-specific patient data.

   :param table: Table to process.
   :type table: cyclops.query.util.TableTypes
   :param operations: Operations to execute, which are of the form:
                      (process function, arguments to pass, keyword arguments to pass).
   :param user_kwargs: Keyword arguments specified by the calling function, or user.
                       If a keyword argument is None, it is discarded.

   :returns: Constructed query, wrapped in an interface object.
   :rtype: cyclops.query.interface.QueryInterface















   ..
       !! processed by numpydoc !!

.. py:class:: Drop

   
   Drop some columns.

   :param cols: Columns to drop.
   :type cols: str or list of str















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: Rename

   
   Rename some columns.

   :param rename_map: Map from an existing column name to another name.
   :type rename_map: dict
   :param check_exists: Whether to check if all of the keys in the map exist as columns.
   :type check_exists: bool















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table:
      :type table: sqlalchemy.sql.selectable.Select or sqlalchemy.sql.selectable.Subquery
      :param or sqlalchemy.sql.schema.Table or cyclops.query.utils.DBTable: Table on which to perform the operation.

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: Substring

   
   Get substring of a string column.

   :param col: Name of column which has string, where substring needs
               to be extracted.
   :type col: str
   :param start_index: Start index of substring.
   :type start_index: int
   :param stop_index: Name of the new column with extracted substring.
   :type stop_index: str















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table:
      :type table: sqlalchemy.sql.selectable.Select or sqlalchemy.sql.selectable.Subquery
      :param or sqlalchemy.sql.schema.Table or cyclops.query.utils.DBTable: Table on which to perform the operation.

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: Reorder

   
   Reorder the columns in a table.

   :param cols: Complete list of table column names in the new order.
   :type cols: list of str















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ReorderAfter(cols: Union[str, List[str]], after: str)

   
   Reorder a number of columns to come after a specified column.

   cols: list of str
       Ordered list of column names which will come after a specified column.
   after: str
       Column name for the column after which the other columns will follow.















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: FilterColumns

   
   Keep only the specified columns in a table.

   :param cols: The columns to keep.
   :type cols: str or list of str















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: Trim

   
   Trim the whitespace from some string columns.

   :param cols: Columns to trim.
   :type cols: str or list of str
   :param new_col_labels: If specified, create new columns with these labels. Otherwise,
                          apply the function to the existing columns.
   :type new_col_labels: str or list of str, optional















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: Literal

   
   Add a literal column to a table.

   :param value: Value of the literal, e.g., a string or integer.
   :type value: any
   :param col: Label of the new literal column.
   :type col: str















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ExtractTimestampComponent

   
   Extract a component such as year or month from a timestamp column.

   :param timestamp_col: Timestamp column from which to extract the time component.
   :type timestamp_col: str
   :param extract_str: Information to extract, e.g., "year", "month"
   :type extract_str: str
   :param label: Column label for the extracted column.
   :type label: str















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: AddNumeric

   
   Add a numeric value to some columns.

   :param add_to: Column names specifying to which columns is being added.
   :type add_to: str or list of str
   :param num: Adds this value to the add_to columns.
   :type num: int or float
   :param new_col_labels: If specified, create new columns with these labels. Otherwise,
                          apply the function to the existing columns.
   :type new_col_labels: str or list of str, optional















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: AddDeltaConstant

   
   Construct and add a datetime.timedelta object to some columns.

   :param add_to: Column names specifying to which columns is being added.
   :type add_to: str or list of str
   :param delta: A timedelta object.
   :type delta: datetime.timedelta
   :param new_col_labels: If specified, create new columns with these labels. Otherwise,
                          apply the function to the existing columns.
   :type new_col_labels: str or list of str, optional















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: AddColumn

   
   Add an column to some columns.

   Pay attention to column types. Some combinations will work,
   whereas others will not.

   :param add_to: Column names specifying to which columns is being added.
   :type add_to: str or list of str
   :param col: Column name of column to add to the add_to columns.
   :type col: str
   :param negative: Subtract the column rather than adding.
   :type negative: bool, optional
   :param new_col_labels: If specified, create new columns with these labels. Otherwise,
                          apply the function to the existing columns.
   :type new_col_labels: str or list of str, optional















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: AddDeltaColumns(add_to: Union[str, List[str]], negative: Optional[bool] = False, new_col_labels: Optional[Union[str, List[str]]] = None, **delta_kwargs)

   
   Construct and add an interval column to some columns.

   :param add_to: Column names specifying to which columns is being added.
   :type add_to: str or list of str
   :param add: Column object of type interval.
   :type add: Column
   :param negative: Subtract the object rather than adding.
   :type negative: bool, optional
   :param new_col_labels: If specified, create new columns with these labels. Otherwise,
                          apply the function to the existing columns.
   :type new_col_labels: str or list of str, optional
   :param \*\*delta_kwargs: The arguments used to create the Interval column.















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: Cast

   
   Cast columns to a specified type.

   Currently supporting conversions to str, int, float, date and timestamp.

   :param cols: Columns to = cast.
   :type cols: str or list of str
   :param type_: Name of type to which to convert. Must be supported.
   :type type_: str















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes)

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: Join(join_table: cyclops.query.util.TableTypes, on: Union[str, List[str], tuple, List[tuple], None] = None, on_to_type: Union[type, List[type], None] = None, cond: Union[sqlalchemy.sql.elements.BinaryExpression, None] = None, table_cols: Union[str, List[str], None] = None, join_table_cols: Union[str, List[str], None] = None, isouter: Optional[bool] = False)

   
   Join a table with another table.

   :param join_table: Table on which to join.
   :type join_table: cyclops.query.util.TableTypes
   :param on: A list of strings or tuples representing columns on which to join.
              Strings represent columns of same name in both tables. A tuple of
              style (table_col, join_table_col) is used to join on columns of
              different names. Suggested to specify this parameter as opposed to
              cond.
   :type on: list of str or tuple, optional
   :param on_to_type: A list of types to which to convert the on columns before joining. Useful when
                      two columns have the same values but in different format, e.g., strings of int.
   :type on_to_type: list of type, optional
   :param cond: Condition on which to join to tables.
   :type cond: BinaryExpression, optional
   :param table_cols: Filters to keep only these columns from the table.
   :type table_cols: str or list of str, optional
   :param join_table_cols: Filters to keep only these columns from the join_table.
   :param isouter: Flag to say if the join is a left outer join.

   .. warning::

      If neither on nor cond parameters are specified, an
      expensive Cartesian product is performed.















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ConditionEquals(col: str, value: Any, not_: bool = False, binarize_col: Optional[str] = None, **cond_kwargs)

   
   Filter rows based on being equal, or not equal, to some value.

   :param col: Column name on which to condition.
   :type col: str
   :param value: Value to equal.
   :type value: any
   :param not_: Take negation of condition.
   :type not_: bool, default=False
   :param binarize_col: If specified, create a Boolean column of name binarize_col instead of filtering.
   :type binarize_col: str, optional
   :param \*\*cond_kwargs: Optional keyword arguments for processing the condition.















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ConditionIn(col: str, values: Union[Any, List[Any]], not_: bool = False, binarize_col: Optional[str] = None, **cond_kwargs)

   
   Filter rows based on having a value in list of values.

   :param col: Column name on which to condition.
   :type col: str
   :param values: Values in which the column value must be.
   :type values: any or list of any
   :param not_: Take negation of condition.
   :type not_: bool, default=False
   :param binarize_col: If specified, create a Boolean column of name binarize_col instead of filtering.
   :type binarize_col: str, optional
   :param \*\*cond_kwargs: Optional keyword arguments for processing the condition.















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ConditionSubstring(col: str, substrings: Union[str, List[str]], any_: bool = True, not_: bool = False, binarize_col: Optional[str] = None, **cond_kwargs)

   
   Filter rows on based on having substrings.

   Can be specified whether it must have any or all of the specified substrings.
   This makes no difference when only one substring is provided

   :param col: Column name on which to condition.
   :type col: str
   :param substrings: Substrings.
   :type substrings: any
   :param any_: If true, the row must have just one of the substrings. If false, it must
                have all of the substrings.
   :type any_: bool, default=True
   :param not_: Take negation of condition.
   :type not_: bool, default=False
   :param binarize_col: If specified, create a Boolean column of name binarize_col instead of filtering.
   :type binarize_col: str, optional
   :param \*\*cond_kwargs: Optional keyword arguments for processing the condition.















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ConditionStartsWith(col: str, string: str, not_: bool = False, binarize_col: Optional[str] = None, **cond_kwargs)

   
   Filter rows based on starting with some string.

   :param col: Column name on which to condition.
   :type col: str
   :param string: String.
   :type string: any
   :param not_: Take negation of condition.
   :type not_: bool, default=False
   :param binarize_col: If specified, create a Boolean column of name binarize_col instead of filtering.
   :type binarize_col: str, optional
   :param \*\*cond_kwargs: Optional keyword arguments for processing the condition.















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ConditionEndsWith(col: str, string: str, not_: bool = False, binarize_col: Optional[str] = None, **cond_kwargs)

   
   Filter rows based on ending with some string.

   :param col: Column name on which to condition.
   :type col: str
   :param string: String.
   :type string: any
   :param not_: Take negation of condition.
   :type not_: bool, default=False
   :param binarize_col: If specified, create a Boolean column of name binarize_col instead of filtering.
   :type binarize_col: str, optional
   :param \*\*cond_kwargs: Optional keyword arguments for processing the condition.















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ConditionInYears(timestamp_col: str, years: Union[int, List[int]], not_: bool = False, binarize_col: Optional[str] = None)

   
   Filter rows based on a timestamp column being in a list of years.

   :param timestamp_col: Timestamp column name.
   :type timestamp_col: str
   :param years: Years in which the timestamps must be.
   :type years: int or list of int
   :param not_: Take negation of condition.
   :type not_: bool, default=False
   :param binarize_col: If specified, create a Boolean column of name binarize_col instead of filtering.
   :type binarize_col: str, optional















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ConditionInMonths(timestamp_col: str, months: Union[int, List[int]], not_: bool = False, binarize_col: Optional[str] = None)

   
   Filter rows based on a timestamp being in a list of years.

   :param timestamp_col: Timestamp column name.
   :type timestamp_col: str
   :param months: Months in which the timestamps must be.
   :type months: int or list of int
   :param not_: Take negation of condition.
   :type not_: bool, default=False
   :param binarize_col: If specified, create a Boolean column of name binarize_col instead of filtering.
   :type binarize_col: str, optional















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ConditionBeforeDate(timestamp_col: str, timestamp: Union[str, datetime.datetime])

   
   Filter rows based on a timestamp being before some date.

   :param timestamp_col: Timestamp column name.
   :type timestamp_col: str
   :param timestamp: A datetime object or str in YYYY-MM-DD format.
   :type timestamp: str or datetime.datetime















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: ConditionAfterDate(timestamp_col: str, timestamp: Union[str, datetime.datetime])

   
   Filter rows based on a timestamp being after some date.

   :param timestamp_col: Timestamp column name.
   :type timestamp_col: str
   :param timestamp: A datetime object or str in YYYY-MM-DD format.
   :type timestamp: str or datetime.datetime















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: Limit

   
   Limit the number of rows returned in a query.

   :param number: Number of rows to return in the limit.
   :type number: int















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: RandomizeOrder

   
   Randomize order of table rows.

   Useful when the data is ordered, so certain rows cannot
   be seen or analyzed when limited.

   .. warning:: Becomes quite slow on large tables.















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: DropNulls

   
   Remove rows with null values in some specified columns.

   :param cols: Columns in which, if a value is null, the corresponding row
                is removed.
   :type cols: str or list of str















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: OrderBy

   
   Order, or sort, the rows of a table by some columns.

   :param cols: Columns by which to order.
   :type cols: str or list of str
   :param ascending: Whether to order each columns by ascending (True) or descending (False).
                     If not provided, orders all by ascending.
   :type ascending: bool or list of bool















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


.. py:class:: GroupByAggregate

   
   Aggregate over a group by object.

   :param groupby_cols: Columns by which to group.
   :type groupby_cols: str or list of str
   :param aggfuncs: Specify a dictionary of key-value pairs:
                    column name: aggfunc string or
                    column name: (aggfunc string, new column label) or
                    This labelling allows for the aggregation of the same column with
                    different functions.
   :type aggfuncs: dict
   :param aggseps: Specify a dictionary of key-value pairs:
                   column name: string_aggfunc separator
                   If string_agg used as aggfunc for a column, then a separator must be provided
                   for the same column.
   :type aggseps: dict, optional

   .. rubric:: Examples

   >>> GroupByAggregate("person_id", {"person_id": "count"})(table)
   >>> GroupByAggregate("person_id", {"person_id": ("count", "visit_count")})(table)
   >>> GroupByAggregate("person_id", {"lab_name": "string_agg"}, {"lab_name": ", "})(table)  # noqa: E501, pylint: disable=line-too-long















   ..
       !! processed by numpydoc !!
   .. py:method:: __call__(table: cyclops.query.util.TableTypes) -> sqlalchemy.sql.selectable.Subquery

      
      Process the table.

      :param table: Table on which to perform the operation.
      :type table: cyclops.query.util.TableTypes

      :returns: Processed table.
      :rtype: sqlalchemy.sql.selectable.Subquery















      ..
          !! processed by numpydoc !!


