:py:mod:`cyclops.process.feature.handle_types`
==============================================

.. py:module:: cyclops.process.feature.handle_types

.. autoapi-nested-parse::

   Handling feature types.

   ..
       !! processed by numpydoc !!


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   cyclops.process.feature.handle_types.get_unique
   cyclops.process.feature.handle_types.valid_feature_type
   cyclops.process.feature.handle_types._type_to_dtype
   cyclops.process.feature.handle_types.to_dtype
   cyclops.process.feature.handle_types._valid_string
   cyclops.process.feature.handle_types._convertible_to_string
   cyclops.process.feature.handle_types._to_string
   cyclops.process.feature.handle_types._valid_numeric
   cyclops.process.feature.handle_types._convertible_to_numeric
   cyclops.process.feature.handle_types._to_numeric
   cyclops.process.feature.handle_types._convertible_to_categorical
   cyclops.process.feature.handle_types._valid_ordinal
   cyclops.process.feature.handle_types._convertible_to_ordinal
   cyclops.process.feature.handle_types._numeric_categorical_mapping
   cyclops.process.feature.handle_types._to_ordinal
   cyclops.process.feature.handle_types._valid_binary
   cyclops.process.feature.handle_types._convertible_to_binary
   cyclops.process.feature.handle_types._to_binary
   cyclops.process.feature.handle_types._valid_categorical_indicator
   cyclops.process.feature.handle_types._convertible_to_categorical_indicators
   cyclops.process.feature.handle_types._to_categorical_indicators
   cyclops.process.feature.handle_types.convertible_to_type
   cyclops.process.feature.handle_types.is_valid
   cyclops.process.feature.handle_types.normalize_data
   cyclops.process.feature.handle_types._to_type
   cyclops.process.feature.handle_types.to_types
   cyclops.process.feature.handle_types._infer_type
   cyclops.process.feature.handle_types.infer_types
   cyclops.process.feature.handle_types.collect_indicators



.. py:function:: get_unique(values: Union[numpy.ndarray, pandas.Series], unique: Optional[numpy.ndarray] = None) -> numpy.ndarray

   
   Get the unique values of pandas series.

   The utility of this function comes from checking whether the
   unique values have already been calculated. This function
   assumes that if the unique values are passed, they are correct.

   :param values: Values for which to get the unique values.
   :type values: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: The unique values.
   :rtype: numpy.ndarray















   ..
       !! processed by numpydoc !!

.. py:function:: valid_feature_type(type_: str, raise_error: bool = True) -> bool

   
   Check whether a feature type name is valid.

   :param type_: Feature type name.
   :type type_: str
   :param raise_error: Whether to raise an error is the type is invalid.
   :type raise_error: bool, default = True

   :returns: Whether the type is valid.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _type_to_dtype(type_: str) -> Optional[Union[type, str]]

   
   Get the Pandas datatype for a feature type name.

   :param type_: Feature type name.
   :type type_: str

   :returns: The feature's Pandas datatype, or None if no data type
             conversion is desired.
   :rtype: type or str or None















   ..
       !! processed by numpydoc !!

.. py:function:: to_dtype(series: pandas.Series, type_: str) -> pandas.Series

   
   Set the series datatype according to the feature type.

   :param type_: Feature type name.
   :type type_: str
   :param series: Feature data.
   :type series: pandas.Series, default = None

   :returns: The feature with the corresponding datatype.
   :rtype: pandas.Series















   ..
       !! processed by numpydoc !!

.. py:function:: _valid_string(series: pandas.Series, unique: Optional[numpy.ndarray] = None, raise_error: bool = False) -> bool

   
   Check whether a feature is a valid string type.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional
   :param raise_error: Whether to raise an error if invalid.
   :type raise_error: bool, default = False

   :returns: Whether the feature is a valid type.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _convertible_to_string(series: pandas.Series, unique: Optional[numpy.ndarray] = None, raise_error: bool = False) -> bool

   
   Check whether a feature can be converted to type string.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional
   :param raise_error: Whether to raise an error if the type cannot be converted.
   :type raise_error: bool, default = False

   :returns: Whether the feature can be converted.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _to_string(series: pandas.Series, unique: Optional[numpy.ndarray] = None) -> Tuple[pandas.Series, Dict[str, Any]]

   
   Convert type to string.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Tuple (pandas.Series, dict) with the updated feature data
             and metadata respectively.
   :rtype: tuple















   ..
       !! processed by numpydoc !!

.. py:function:: _valid_numeric(series: pandas.Series, unique: Optional[numpy.ndarray] = None, raise_error: bool = False) -> bool

   
   Check whether a feature is a valid numeric type.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional
   :param raise_error: Whether to raise an error if invalid.
   :type raise_error: bool, default = False

   :returns: Whether the feature is a valid type.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _convertible_to_numeric(series: pandas.Series, unique: Optional[numpy.ndarray] = None, raise_error: bool = False) -> bool

   
   Check whether a feature can be converted to type numeric.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional
   :param raise_error: Whether to raise an error if the type cannot be converted.
   :type raise_error: bool, default = False

   :returns: Whether the feature can be converted.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _to_numeric(series: pandas.Series, unique: Optional[numpy.ndarray] = None) -> Tuple[pandas.Series, Dict[str, Any]]

   
   Convert type to numeric.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Tuple (pandas.Series, dict) with the updated feature data
             and metadata respectively.
   :rtype: tuple















   ..
       !! processed by numpydoc !!

.. py:function:: _convertible_to_categorical(series: pandas.Series, category_min: int = None, category_max: int = None, unique: Optional[numpy.ndarray] = None, raise_error_over_max: bool = False, raise_error_under_min: bool = False) -> bool

   
   Check whether a feature can be converted to some categorical type.

   :param series: Feature data.
   :type series: pandas.Series
   :param category_min: The minimum number of categories allowed.
   :type category_min: int, optional
   :param category_max: The maximum number of categories allowed.
   :type category_max: int, optional
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional
   :param raise_error_over_max: Whether to raise an error if there are more categories than max.
   :type raise_error_over_max: bool, default = False
   :param raise_error_under_min: Whether to raise an error if there are less categories than min.
   :type raise_error_under_min: bool, default = False

   :returns: Whether the feature can be converted.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _valid_ordinal(series: pandas.Series, unique: Optional[numpy.ndarray] = None, raise_error: bool = False) -> bool

   
   Check whether a feature is a valid ordinal type.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional
   :param raise_error: Whether to raise an error if invalid.
   :type raise_error: bool, default = False

   :returns: Whether the feature is a valid type.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _convertible_to_ordinal(series: pandas.Series, unique: Optional[numpy.ndarray] = None, category_max: int = 20, raise_error_over_max: bool = False) -> bool

   
   Check whether a feature can be converted to type ordinal.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional
   :param category_max: The number of categories above which the feature is not considered ordinal.
   :type category_max: int, optional
   :param raise_error_over_max: Whether to raise an error if there are more categories than max.
   :type raise_error_over_max: bool, default = False

   :returns: Whether the feature can be converted.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _numeric_categorical_mapping(series: pandas.Series, unique: Optional[numpy.ndarray] = None) -> Tuple[pandas.Series, Dict[str, Any]]

   
   Map values to categories in a series.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Tuple (pandas.Series, dict) with the updated feature data
             and metadata respectively.
   :rtype: tuple















   ..
       !! processed by numpydoc !!

.. py:function:: _to_ordinal(series: pandas.Series, unique: Optional[numpy.ndarray] = None) -> Tuple[pandas.Series, Dict[str, Any]]

   
   Convert type to ordinal.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Tuple (pandas.Series, dict) with the updated feature data
             and metadata respectively.
   :rtype: tuple















   ..
       !! processed by numpydoc !!

.. py:function:: _valid_binary(series: pandas.Series, unique: Optional[numpy.ndarray] = None, raise_error: bool = False) -> bool

   
   Check whether a feature is a valid binary type.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional
   :param raise_error: Whether to raise an error if invalid.
   :type raise_error: bool, default = False

   :returns: Whether the feature is a valid type.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _convertible_to_binary(series: pandas.Series, unique: Optional[numpy.ndarray] = None) -> bool

   
   Check whether a feature can be converted to type binary.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Whether the feature can be converted.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _to_binary(series: pandas.Series, unique: Optional[numpy.ndarray] = None) -> Tuple[pandas.Series, Dict[str, Any]]

   
   Convert type to binary.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Tuple (pandas.Series, dict) with the updated feature data
             and metadata respectively.
   :rtype: tuple















   ..
       !! processed by numpydoc !!

.. py:function:: _valid_categorical_indicator(series: pandas.Series, unique: Optional[numpy.ndarray] = None, raise_error: bool = False) -> bool

   
   Check whether a feature is a valid categorical indicator type.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional
   :param raise_error: Whether to raise an error if invalid.
   :type raise_error: bool, default = False

   :returns: Whether the feature is a valid type.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _convertible_to_categorical_indicators(series: pandas.Series, unique: Optional[numpy.ndarray] = None, category_max: int = 20, raise_error_over_max: bool = False) -> bool

   
   Check whether a feature can be converted to categorical indicators.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Whether the feature can be converted.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: _to_categorical_indicators(data: pandas.DataFrame, col: str, unique: Optional[numpy.ndarray] = None) -> Tuple[pandas.DataFrame, Dict[str, Any]]

   
   Convert type to binary categorical indicators.

   This performs the Pandas equivalent of one-hot encoding.

   :param data: Features data.
   :type data: pandas.DataFrame
   :param col: Feature column being converted.
   :type col: str
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Tuple (pandas.DataFrame, dict) with the updated features data
             and metadata respectively.
   :rtype: tuple















   ..
       !! processed by numpydoc !!

.. py:function:: convertible_to_type(series: pandas.Series, type_: str, unique: numpy.ndarray = None, raise_error: bool = False) -> bool

   
   Check whether a feature can be converted to some type.

   :param series: Feature data.
   :type series: pandas.Series
   :param type_: Feature type name to check for conversion.
   :type type_: str
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Whether the feature can be converted.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: is_valid(series: pandas.Series, type_: str, unique: Optional[numpy.ndarray] = None) -> bool

   
   Check whether a feature is valid as a given type.

   :param series: Feature.
   :type series: pandas.Series
   :param type_: Feature type name.
   :type type_: str
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Whether the feature is valid.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: normalize_data(data: pandas.DataFrame, features: List[str]) -> pandas.DataFrame

   
   Normalize feature data to more easily deal with types.

   :param data: Features data.
   :type data: pandas.DataFrame
   :param features: Features to normalize.
   :type features: list of str

   :returns: Updated features data.
   :rtype: pandas.DataFrame















   ..
       !! processed by numpydoc !!

.. py:function:: _to_type(data: pandas.DataFrame, col: str, new_type: str, unique: Optional[numpy.ndarray] = None) -> Tuple[Union[pandas.Series, pandas.DataFrame], Dict[str, Any]]

   
   Convert a feature to a given type.

   :param data: Features data.
   :type data: pandas.DataFrame
   :param col: Column name for the feature being converted.
   :type col: str
   :param new_type: Feature type name of type to which to convert.
   :type new_type: str
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Tuple (pandas.Series or pandas.DataFrame, dict) with the updated
             features data and metadata respectively. If converting to categorical
             indicators, a DataFrame is returned, otherwise a Series is returned.
   :rtype: tuple















   ..
       !! processed by numpydoc !!

.. py:function:: to_types(data: pandas.DataFrame, new_types: dict) -> Tuple[pandas.DataFrame, Dict[str, Any]]

   
   Convert features to given types.

   :param data: Features data.
   :type data: pandas.DataFrame
   :param new_types: Map from the feature column name to its new type.
   :type new_types: str

   :returns: Tuple (pandas.DataFrame, dict) with the updated features data
             and metadata respectively.
   :rtype: tuple















   ..
       !! processed by numpydoc !!

.. py:function:: _infer_type(series: pandas.Series, unique: Optional[numpy.ndarray] = None) -> str

   
   Infer intended feature type and perform the relevant conversion.

   :param series: Feature data.
   :type series: pandas.Series
   :param unique: Unique values which can be optionally specified.
   :type unique: numpy.ndarray, optional

   :returns: Feature type name.
   :rtype: str















   ..
       !! processed by numpydoc !!

.. py:function:: infer_types(data: pandas.DataFrame, features: List[str]) -> Dict[str, str]

   
   Infer intended feature types and perform the relevant conversions.

   :param data: Feature data.
   :type data: pandas.DataFrame
   :param features: Features to consider.
   :type features: list of str

   :returns: A tuple (pandas.DataFrame, dict) with the updated features data
             and metadata respectively.
   :rtype: tuple















   ..
       !! processed by numpydoc !!

.. py:function:: collect_indicators(data: pandas.DataFrame, categorical: Union[str, List[str]]) -> pandas.DataFrame

   
   Infer and collect indicator features into ordinal categorical features.

   :param data: Features data.
   :type data: pandas.DataFrame
   :param categorical: Names of categorical features. E.g., "hospital" for indicators
                       "hospital_A", "hospital_B"
   :type categorical: str or list of str















   ..
       !! processed by numpydoc !!

