:py:mod:`cyclops.evaluate.metrics.functional.roc`
=================================================

.. py:module:: cyclops.evaluate.metrics.functional.roc

.. autoapi-nested-parse::

   Functions for computing the receiver operating characteristic (ROC) curve.

   ..
       !! processed by numpydoc !!


Module Contents
---------------

.. py:function:: binary_roc_curve(target: numpy.typing.ArrayLike, preds: numpy.typing.ArrayLike, thresholds: Union[int, List[float], numpy.ndarray] = None, pos_label: int = 1) -> Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]

   
   Compute the ROC curve for binary classification tasks.

   :param target: Ground truth (correct) target values.
   :type target: ArrayLike
   :param preds: Estimated probabilities or decision function. If ``preds`` is not in
                 the range [0, 1], a sigmoid function is applied to transform it to
                 the range [0, 1].
   :type preds: ArrayLike
   :param thresholds: Thresholds used for computing the precision and recall scores.
                      If int, then the number of thresholds to use.
                      If list or array, then the thresholds to use.
                      If None, then the thresholds are automatically determined by the
                      unique values in ``preds``.
   :type thresholds: int or list of floats or numpy.ndarray of floats, default=None
   :param pos_label: The label of the positive class.
   :type pos_label: int, optional

   :returns: * **fpr** (*numpy.ndarray*) -- False positive rate.
             * **tpr** (*numpy.ndarray*) -- True positive rate.
             * **thresholds** (*numpy.ndarray*) -- Thresholds used to compute fpr and tpr.

   .. rubric:: Examples

   >>> from cyclops.evaluation.metrics.functional import binary_roc_curve
   >>> target = [1, 0, 1, 0]
   >>> preds = [0.9, 0.2, 0.8, 0.3]
   >>> fpr, tpr, thresholds = binary_roc_curve(target, preds, thresholds=5)
   >>> fpr
   array([0. , 0. , 0. , 0.5, 1. ])
   >>> tpr
   array([0., 1., 1., 1., 1.])
   >>> thresholds
   array([1.  , 0.75, 0.5 , 0.25, 0.  ])















   ..
       !! processed by numpydoc !!

.. py:function:: multiclass_roc_curve(target: numpy.typing.ArrayLike, preds: numpy.typing.ArrayLike, num_classes: int, thresholds: Union[int, List[float], numpy.ndarray] = None) -> Union[Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray], Tuple[List[numpy.ndarray], List[numpy.ndarray], List[numpy.ndarray]]]

   
   Compute the ROC curve for multiclass classification tasks.

   :param target: Ground truth (correct) target values.
   :type target: ArrayLike
   :param preds: Estimated probabilities or decision function. If ``preds`` is not in
                 the range [0, 1], a softmax function is applied to transform it to
                 the range [0, 1].
   :type preds: ArrayLike
   :param num_classes: Number of classes.
   :type num_classes: int
   :param thresholds: Thresholds used for binarizing the predicted probabilities.
                      If int, then the number of thresholds to use.
                      If list or array, then the thresholds to use.
                      If None, then the thresholds are automatically determined by the
                      unique values in ``preds``.
   :type thresholds: int or list of floats or numpy.ndarray of floats, default=None

   :returns: * **fpr** (*numpy.ndarray or list of numpy.ndarray*) -- False positive rate. If ``threshold`` is not None, ``fpr`` is a 1d numpy
               array. Otherwise, ``fpr`` is a list of 1d numpy arrays, one for each
               class.
             * **tpr** (*numpy.ndarray or list of numpy.ndarray*) -- True positive rate. If ``threshold`` is not None, ``tpr`` is a 1d numpy
               array. Otherwise, ``tpr`` is a list of 1d numpy arrays, one for each class.
             * **thresholds** (*numpy.ndarray or list of numpy.ndarray*) -- Thresholds used to compute fpr and tpr. ``threshold`` is not None,
               thresholds is a 1d numpy array. Otherwise, thresholds is a list of
               1d numpy arrays, one for each class.

   .. rubric:: Examples

   >>> from cyclops.evaluation.metrics.functional import multiclass_roc_curve
   >>> target = [1, 0, 2, 0]
   >>> preds = [[0.9, 0.05, 0.05], [0.05, 0.9, 0.05],
   ...         [0.05, 0.05, 0.9], [0.9, 0.05, 0.05]]
   >>> fpr, tpr, thresholds = multiclass_roc_curve(target, preds,
   ...     num_classes=3, thresholds=5
   ... )
   >>> fpr
   array([[0.        , 0.5       , 0.5       , 0.5       , 1.        ],
   [0.        , 0.33333333, 0.33333333, 0.33333333, 1.        ],
   [0.        , 0.        , 0.        , 0.        , 1.        ]])
   >>> tpr
   array([[0. , 0.5, 0.5, 0.5, 1. ],
   [0. , 0. , 0. , 0. , 1. ],
   [0. , 1. , 1. , 1. , 1. ]])
   >>> thresholds
   array([1.  , 0.75, 0.5 , 0.25, 0.  ])















   ..
       !! processed by numpydoc !!

.. py:function:: multilabel_roc_curve(target: numpy.typing.ArrayLike, preds: numpy.typing.ArrayLike, num_labels: int, thresholds: Union[int, List[float], numpy.ndarray] = None) -> Union[Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray], Tuple[List[numpy.ndarray], List[numpy.ndarray], List[numpy.ndarray]]]

   
   Compute the ROC curve for multilabel classification tasks.

   :param target: Ground truth (correct) target values.
   :type target: ArrayLike
   :param preds: Estimated probabilities or decision function. If ``preds`` is not in
                 the range [0, 1], a sigmoid function is applied to transform it to
                 the range [0, 1].
   :type preds: ArrayLike
   :param num_labels: The number of labels in the dataset.
   :type num_labels: int
   :param thresholds: Thresholds used for binarizing the values of ``preds``.
                      If int, then the number of thresholds to use.
                      If list or array, then the thresholds to use.
                      If None, then the thresholds are automatically determined by the
                      unique values in ``preds``.
   :type thresholds: int or list of floats or numpy.ndarray of floats, default=None

   :returns: * **fpr** (*numpy.ndarray or list of numpy.ndarray*) -- False positive rate. If ``threshold`` is not None, ``fpr`` is a 1d numpy
               array. Otherwise, ``fpr`` is a list of 1d numpy arrays, one for each
               label.
             * **tpr** (*numpy.ndarray or list of numpy.ndarray*) -- True positive rate. If ``threshold`` is not None, ``tpr`` is a 1d numpy
               array. Otherwise, ``tpr`` is a list of 1d numpy arrays, one for each label.
             * **thresholds** (*numpy.ndarray or list of numpy.ndarray*) -- Thresholds used to compute fpr and tpr. ``threshold`` is not None,
               thresholds is a 1d numpy array. Otherwise, thresholds is a list of
               1d numpy arrays, one for each label.

   .. rubric:: Examples

   >>> from cyclops.evaluation.metrics.functional import multilabel_roc_curve
   >>> target = [[0, 1, 0], [0, 1, 1], [1, 0, 1]]
   >>> preds = [[0.1, 0.9, 0.8], [0.05, 0.1, 0.9], [0.8, 0.2, 0.3]]
   >>> fpr, tpr, thresholds = multilabel_roc_curve(target, preds, num_labels=3,
   ...     thresholds=5
   ... )
   >>> fpr
   array([[0., 0., 0., 0., 1.],
   [0., 0., 0., 0., 1.],
   [0., 1., 1., 1., 1.]])
   >>> tpr
   array([[0. , 1. , 1. , 1. , 1. ],
   [0. , 0.5, 0.5, 0.5, 1. ],
   [0. , 0.5, 0.5, 1. , 1. ]])
   >>> thresholds
   array([1.  , 0.75, 0.5 , 0.25, 0.  ])















   ..
       !! processed by numpydoc !!

.. py:function:: roc_curve(target: numpy.typing.ArrayLike, preds: numpy.typing.ArrayLike, task: Literal[binary, multiclass, multilabel], thresholds: Union[int, List[float], numpy.ndarray] = None, pos_label: int = 1, num_classes: int = None, num_labels: int = None) -> Union[Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray], Tuple[List[numpy.ndarray], List[numpy.ndarray], List[numpy.ndarray]]]

   
   Compute the ROC curve for different tasks/input types.

   :param target: Ground truth (correct) target values.
   :type target: ArrayLike
   :param preds: Estimated probabilities or non-thresholded output of decision function.
                 If ``task`` is ``multiclass`` and the values in ``preds`` are not
                 probabilities, they will be converted to probabilities using the softmax
                 function. If ``task`` is ``multilabel`` and the values in ``preds`` are
                 not probabilities, they will be converted to probabilities using the
                 sigmoid function.
   :type preds: ArrayLike
   :param task: The type of task for the input data. One of 'binary', 'multiclass'
                or 'multilabel'.
   :type task: Literal["binary", "multiclass", "multilabel"]
   :param thresholds: Thresholds used for computing the ROC curve. Can be one of:

                      - None: use the unique values of ``preds`` as thresholds
                      - int: generate ``thresholds`` number of evenly spaced values between
                          0 and 1 as thresholds.
                      - list of floats: use the values in the list as thresholds. The list
                          of values should be monotonically increasing. The list will be
                          converted into a numpy array.
                      - numpy.ndarray of floats: use the values in the array as thresholds.
                          The array should be 1d and monotonically increasing.
   :type thresholds: int or list of floats or numpy.ndarray of floats, default=None
   :param pos_label: The label of the positive class.
   :type pos_label: int, default=1
   :param num_classes: The number of classes in the dataset. Required for multiclass tasks.
   :type num_classes: int, optional
   :param num_labels: The number of labels in the dataset. Required for multilabel tasks.
   :type num_labels: int, optional

   :returns: * **fpr** (*numpy.ndarray or list of numpy.ndarray*) -- False positive rate. If ``task`` is 'binary' or ``threshold`` is not None,
               ``fpr`` is a 1d numpy array. If ``task`` is 'multiclass' or 'multilabel',
               and ``threshold`` is None, then ``fpr`` is a list of 1d numpy
               arrays, one for each class or label.
             * **tpr** (*numpy.ndarray or list of numpy.ndarray*) -- True positive rate. If ``task`` is 'binary' or ``threshold`` is not None,
               ``tpr`` is a 1d numpy array. If ``task`` is 'multiclass' or 'multilabel',
               and ``threshold`` is None, then ``tpr`` is a list of 1d numpy
               arrays, one for each class or label.
             * **thresholds** (*numpy.ndarray or list of numpy.ndarray*) -- Thresholds used to compute fpr and tpr. If ``task`` is 'binary' or
               ``threshold`` is not None, ``thresholds`` is a 1d numpy array. If
               ``task`` is 'multiclass' or 'multilabel', and ``threshold`` is None,
               then ``thresholds`` is a list of 1d numpy arrays, one for each class
               or label.

   :raises ValueError: If ``task`` is not one of 'binary', 'multiclass' or 'multilabel'.
   :raises AssertionError: If ``task`` is ``multiclass`` and ``num_classes`` is not provided.
   :raises AssertionError: If ``task`` is ``multilabel`` and ``num_labels`` is not provided.

   .. rubric:: Examples

   >>> # (binary)
   >>> from cyclops.evaluation.metrics.functional import roc_curve
   >>> target = [0, 0, 1, 1]
   >>> preds = [0.1, 0.4, 0.35, 0.8]
   >>> fpr, tpr, thresholds = roc_curve(target, preds, task='binary')
   >>> fpr
   array([0. , 0. , 0.5, 0.5, 1. ])
   >>> tpr
   array([0. , 0.5, 0.5, 1. , 1. ])
   >>> thresholds
   array([1.  , 0.8 , 0.4 , 0.35, 0.1 ])

   >>> # (multiclass)
   >>> from cyclops.evaluation.metrics.functional import roc_curve
   >>> target = [0, 1, 2]
   >>> preds = [[0.9, 0.05, 0.05], [0.05, 0.89, 0.06], [0.02, 0.03, 0.95]]
   >>> fpr, tpr, thresholds = roc_curve(target, preds, task='multiclass',
   ...     num_classes=3
   ... )
   >>> fpr
   [array([0. , 0. , 0.5, 1. ]),
   array([0. , 0. , 0.5, 1. ]),
   array([0. , 0. , 0.5, 1. ])]
   >>> tpr
   [array([0., 1., 1., 1.]), array([0., 1., 1., 1.]), array([0., 1., 1., 1.])]
   >>> thresholds
   [array([1.  , 0.9 , 0.05, 0.02]),
   array([1.  , 0.89, 0.05, 0.03]),
   array([1.  , 0.95, 0.06, 0.05])]

   >>> # (multilabel)
   >>> from cyclops.evaluation.metrics.functional import roc_curve
   >>> target = [[1, 1], [0, 1], [1, 0]]
   >>> preds = [[0.9, 0.8], [0.2, 0.7], [0.8, 0.3]]
   >>> fpr, tpr, thresholds = roc_curve(target, preds, task='multilabel',
   ...     num_labels=2
   ... )
   >>> fpr
   [array([0. , 0.5, 1. , 1. ]), array([0., 0., 0., 1.])]
   >>> tpr
   [array([0., 0., 0., 1.]), array([0. , 0.5, 1. , 1. ])]
   >>> thresholds
   [array([1. , 0.9, 0.8, 0.2]), array([1. , 0.8, 0.7, 0.3])]















   ..
       !! processed by numpydoc !!

