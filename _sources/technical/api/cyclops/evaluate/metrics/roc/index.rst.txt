:py:mod:`cyclops.evaluate.metrics.roc`
======================================

.. py:module:: cyclops.evaluate.metrics.roc

.. autoapi-nested-parse::

   Classes for computing ROC metrics.

   ..
       !! processed by numpydoc !!


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   cyclops.evaluate.metrics.roc.BinaryROCCurve
   cyclops.evaluate.metrics.roc.MulticlassROCCurve
   cyclops.evaluate.metrics.roc.MultilabelROCCurve
   cyclops.evaluate.metrics.roc.ROCCurve




.. py:class:: BinaryROCCurve(thresholds: Union[int, List[float], numpy.ndarray] = None, pos_label: int = 1)

   Bases: :py:obj:`cyclops.evaluate.metrics.BinaryPrecisionRecallCurve`

   
   Compute the ROC curve for binary classification tasks.

   :param thresholds: Thresholds used for computing the precision and recall scores.
                      If int, then the number of thresholds to use.
                      If list or array, then the thresholds to use.
                      If None, then the thresholds are automatically determined by the
                      unique values in ``preds``.
   :type thresholds: int or list of floats or numpy.ndarray of floats, default=None
   :param pos_label: The label of the positive class.
   :type pos_label: int, default=1

   .. rubric:: Examples

   >>> from cyclops.evaluation.metrics import BinaryROCCurve
   >>> target = [0, 0, 1, 1]
   >>> preds = [0.1, 0.4, 0.35, 0.8]
   >>> metric = BinaryROCCurve()
   >>> metric(target, preds)
   (array([0. , 0. , 0.5, 0.5, 1. ]),
   array([0. , 0.5, 0.5, 1. , 1. ]),
   array([1.  , 0.8 , 0.4 , 0.35, 0.1 ]))
   >>> metric.reset_state()
   >>> target = [[1, 1, 0, 0], [0, 0, 1, 1]]
   >>> preds = [[0.1, 0.2, 0.3, 0.4], [0.6, 0.5, 0.4, 0.3]]
   >>> for t, p in zip(target, preds):
   ...     metric.update_state(t, p)
   >>> metric.compute()
   (array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.  , 1.  ]),
   array([0.  , 0.  , 0.  , 0.25, 0.5 , 0.75, 1.  ]),
   array([1. , 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]))















   ..
       !! processed by numpydoc !!
   .. py:method:: compute() -> Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]

      
      Compute the ROC curve from the state variables.
















      ..
          !! processed by numpydoc !!


.. py:class:: MulticlassROCCurve(num_classes: int, thresholds: Union[int, List[float], numpy.ndarray] = None)

   Bases: :py:obj:`cyclops.evaluate.metrics.MulticlassPrecisionRecallCurve`

   
   Compute the ROC curve for multiclass classification tasks.

   :param target: Ground truth (correct) target values.
   :type target: ArrayLike
   :param preds: Estimated probabilities or decision function. If ``preds`` is not in
                 the range [0, 1], a softmax function is applied to transform it to
                 the range [0, 1].
   :type preds: ArrayLike
   :param num_classes: Number of classes.
   :type num_classes: int
   :param thresholds: Thresholds used for binarizing the predicted probabilities.
                      If int, then the number of thresholds to use.
                      If list or array, then the thresholds to use.
                      If None, then the thresholds are automatically determined by the
                      unique values in ``preds``.
   :type thresholds: int or list of floats or numpy.ndarray of floats, default=None

   .. rubric:: Examples

   >>> from cyclops.evaluation.metrics import MulticlassROCCurve
   >>> target = [0, 1, 2, 0]
   >>> preds = [[0.05, 0.95, 0], [0.1, 0.8, 0.1],
   ...         [0.2, 0.2, 0.6], [0.9, 0.1, 0]]
   >>> metric = MulticlassROCCurve(num_classes=3, thresholds=4)
   >>> metric(target, preds)
   (array([[0.        , 0.        , 0.        , 1.        ],
           [0.        , 0.33333333, 0.33333333, 1.        ],
           [0.        , 0.        , 0.        , 1.        ]]),
   array([[0. , 0.5, 0.5, 1. ],
           [0. , 1. , 1. , 1. ],
           [0. , 0. , 1. , 1. ]]),
   array([1.        , 0.66666667, 0.33333333, 0.        ]))
   >>> metric.reset_state()
   >>> target = [[1, 1, 0, 0], [0, 0, 1, 1]]
   >>> preds = [[[0.1, 0.2, 0.7], [0.5, 0.4, 0.1],
   ...         [0.2, 0.3, 0.5], [0.8, 0.1, 0.1]],
   ...         [[0.1, 0.2, 0.7], [0.5, 0.4, 0.1],
   ...         [0.2, 0.3, 0.5], [0.8, 0.1, 0.1]]]
   >>> for t, p in zip(target, preds):
   ...     metric.update_state(t, p)
   >>> metric.compute()
   (array([[0.  , 0.25, 0.5 , 1.  ],
           [0.  , 0.  , 0.25, 1.  ],
           [0.  , 0.25, 0.5 , 1.  ]]),
   array([[0.  , 0.25, 0.5 , 1.  ],
           [0.  , 0.  , 0.25, 1.  ],
           [0.  , 0.  , 0.  , 0.  ]]),
   array([1.        , 0.66666667, 0.33333333, 0.        ]))















   ..
       !! processed by numpydoc !!
   .. py:method:: compute() -> Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]

      
      Compute the ROC curve from the state variables.
















      ..
          !! processed by numpydoc !!


.. py:class:: MultilabelROCCurve(num_labels: int, thresholds: Union[int, List[float], numpy.ndarray] = None)

   Bases: :py:obj:`cyclops.evaluate.metrics.MultilabelPrecisionRecallCurve`

   
   Compute the ROC curve for multilabel classification tasks.

   :param num_labels: The number of labels in the dataset.
   :type num_labels: int
   :param thresholds: Thresholds used for binarizing the values of ``preds``.
                      If int, then the number of thresholds to use.
                      If list or array, then the thresholds to use.
                      If None, then the thresholds are automatically determined by the
                      unique values in ``preds``.
   :type thresholds: int or list of floats or numpy.ndarray of floats, default=None

   .. rubric:: Examples

   >>> from cyclops.evaluation.metrics import MultilabelROCCurve
   >>> target = [[1, 1, 0], [0, 1, 0]]
   >>> preds = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]
   >>> metric = MultilabelROCCurve(num_labels=3, thresholds=4)
   >>> metric(target, preds)
   (array([[0. , 0. , 0. , 1. ],
           [0. , 0. , 0. , 0. ],
           [0. , 0.5, 0.5, 1. ]]),
   array([[0., 0., 0., 1.],
           [0., 1., 1., 1.],
           [0., 0., 0., 0.]]),
   array([1.        , 0.66666667, 0.33333333, 0.        ]))
   >>> metric.reset_state()
   >>> target = [[[1, 1, 0], [0, 1, 0]], [[1, 1, 0], [0, 1, 0]]]
   >>> preds = [[[0.1, 0.9, 0.8], [0.05, 0.95, 0]],
   ...         [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]]
   >>> for t, p in zip(target, preds):
   ...     metric.update_state(t, p)
   >>> metric.compute()
   (array([[0. , 0. , 0. , 1. ],
           [0. , 0. , 0. , 0. ],
           [0. , 0.5, 0.5, 1. ]]),
   array([[0., 0., 0., 1.],
           [0., 1., 1., 1.],
           [0., 0., 0., 0.]]),
   array([1.        , 0.66666667, 0.33333333, 0.        ]))















   ..
       !! processed by numpydoc !!
   .. py:method:: compute() -> Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]

      
      Compute the ROC curve from the state variables.
















      ..
          !! processed by numpydoc !!


.. py:class:: ROCCurve

   Bases: :py:obj:`cyclops.evaluate.metrics.metric.Metric`

   
   Compute the ROC curve for different types of classification tasks.

   :param task: The type of task for the input data. One of 'binary', 'multiclass'
                or 'multilabel'.
   :type task: Literal["binary", "multiclass", "multilabel"]
   :param thresholds: Thresholds used for computing the ROC curve. Can be one of:

                      - None: use the unique values of ``preds`` as thresholds
                      - int: generate ``thresholds`` number of evenly spaced values between
                          0 and 1 as thresholds.
                      - list of floats: use the values in the list as thresholds. The list
                          of values should be monotonically increasing. The list will be
                          converted into a numpy array.
                      - numpy.ndarray of floats: use the values in the array as thresholds.
                          The array should be 1d and monotonically increasing.
   :type thresholds: int or list of floats or numpy.ndarray of floats, default=None
   :param pos_label: Label to consider as positive for binary classification tasks.
   :type pos_label: int, default=1
   :param num_classes: The number of classes in the dataset. Required if ``task`` is
                       ``"multiclass"``.
   :type num_classes: int, optional
   :param num_labels: The number of labels in the dataset. Required if ``task`` is
                      ``"multilabel"``.
   :type num_labels: int, optional

   .. rubric:: Examples

   >>> # (binary)
   >>> from cyclops.evaluation.metrics import ROCCurve
   >>> target = [0, 0, 1, 1]
   >>> preds = [0.1, 0.4, 0.35, 0.8]
   >>> metric = ROCCurve(task="binary", thresholds=None)
   >>> metric(target, preds)
   (array([0. , 0. , 0.5, 0.5, 1. ]),
   array([0. , 0.5, 0.5, 1. , 1. ]),
   array([1.  , 0.8 , 0.4 , 0.35, 0.1 ]))
   >>> metric.reset_state()
   >>> target = [[1, 1, 0, 0], [0, 0, 1, 1]]
   >>> preds = [[0.1, 0.2, 0.3, 0.4], [0.6, 0.5, 0.4, 0.3]]
   >>> for t, p in zip(target, preds):
   ...     metric.update_state(t, p)
   >>> metric.compute()
   (array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.  , 1.  ]),
   array([0.  , 0.  , 0.  , 0.25, 0.5 , 0.75, 1.  ]),
   array([1. , 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]))

   >>> # (multiclass)
   >>> from cyclops.evaluation.metrics import ROCCurve
   >>> target = [[1, 1, 0], [0, 1, 0]]
   >>> preds = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]
   >>> metric = ROCCurve(task="multiclass", num_classes=3, thresholds=4)
   >>> metric(target, preds)
   (array([[0. , 0. , 0. , 1. ],
           [0. , 0. , 0. , 0. ],
           [0. , 0.5, 0.5, 1. ]]),
   array([[0., 0., 0., 1.],
           [0., 1., 1., 1.],
           [0., 0., 0., 0.]]),
   array([1.        , 0.66666667, 0.33333333, 0.        ]))
   >>> metric.reset_state()
   >>> target = [[[1, 1, 0], [0, 1, 0]], [[1, 1, 0], [0, 1, 0]]]
   >>> preds = [[[0.1, 0.9, 0.8], [0.05, 0.95, 0]],
   ...         [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]]
   >>> for t, p in zip(target, preds):
   ...     metric.update_state(t, p)
   >>> metric.compute()
   (array([[0. , 0. , 0. , 1. ],
           [0. , 0. , 0. , 0. ],
           [0. , 0.5, 0.5, 1. ]]),
   array([[0., 0., 0., 1.],
           [0., 1., 1., 1.],
           [0., 0., 0., 0.]]),
   array([1.        , 0.66666667, 0.33333333, 0.        ]))

   >>> # (multilabel)
   >>> from cyclops.evaluation.metrics import ROCCurve
   >>> target = [[1, 1, 0], [0, 1, 0]]
   >>> preds = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]
   >>> metric = ROCCurve(task="multilabel", num_labels=3, thresholds=4)
   >>> metric(target, preds)
   (array([[0. , 0. , 0. , 1. ],
           [0. , 0. , 0. , 0. ],
           [0. , 0.5, 0.5, 1. ]]),
   array([[0., 0., 0., 1.],
           [0., 1., 1., 1.],
           [0., 0., 0., 0.]]),
   array([1.        , 0.66666667, 0.33333333, 0.        ]))
   >>> metric.reset_state()
   >>> target = [[[1, 1, 0], [0, 1, 0]], [[1, 1, 0], [0, 1, 0]]]
   >>> preds = [[[0.1, 0.9, 0.8], [0.05, 0.95, 0]],
   ...         [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]]
   >>> for t, p in zip(target, preds):
   ...     metric.update_state(t, p)
   >>> metric.compute()
   (array([[0. , 0. , 0. , 1. ],
           [0. , 0. , 0. , 0. ],
           [0. , 0.5, 0.5, 1. ]]),
   array([[0., 0., 0., 1.],
           [0., 1., 1., 1.],
           [0., 0., 0., 0.]]),
   array([1.        , 0.66666667, 0.33333333, 0.        ]))















   ..
       !! processed by numpydoc !!

